<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="../sass/tandwiel.png">
    <title>EV - Split Clash</title>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <link href="../css/custom.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
</head>
<body> 

    <!-- Navigatiebalk -->
    <nav class="navbar navbar-expand-lg bg-primary shadow rounded">
        <a class="nav-link text-white font-weight-bold" href="../index.html">Esmée Veldhuizen</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNav">
            <ul class="navbar-nav ml-auto">
                <li class="nav-item">
                    <a class="nav-link text-white" href="../index.html">Main page</a>
                </li>
                <li class="nav-item dropdown">
                    <a class="nav-link dropdown-toggle text-white" href="#" id="projectDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                        ☰
                    </a>
                    <div class="dropdown-menu dropdown-menu-right bg-primary" aria-labelledby="projectDropdown">
                        <a class="dropdown-item text-white" href="stardelivery.html">Star Delivery</a>
                        <a class="dropdown-item text-white" href="theexperiment.html">The Experiment: Nature Edition</a>
                        <a class="dropdown-item text-white" href="tristartriumph.html">Tristar Triumph</a>
                        <a class="dropdown-item text-white" href="unrealengine.html">Alter Ego</a>
                        <a class="dropdown-item text-white" href="javascript.html">Dot by dot</a>
                        <div class="dropdown-divider"></div>
                        <a class="dropdown-item text-white" href="../gamejam.html">GlobalGameJam</a>
                    </div>
                </li>
            </ul>
        </div>
    </nav>

    <!-- Hero Section -->
    <section class="hero text-white text-center py-5 position-relative d-flex justify-content-center align-items-center" style="background-image: url('../images/splitt/split1.png'); background-size: cover; background-position: center;">
        <div class="overlay position-absolute w-100 h-100 bg-dark opacity-50"></div>
        <div class="container position-relative z-index-2">
            <h1 class="display-3 fw-bold glow-text">Split Clash</h1>
            <p class="lead">A game made in 8 weeks with 2 developers and 2 artists</p>
        </div>
    </section>

    <!-- Over de game (Split layout) -->
    <section class="game-info container py-5">
        <div class="row align-items-center">
            <div class="ratio ratio-16x9 mx-auto" style="max-width: 500px;">
  <iframe 
    src="https://www.youtube.com/embed/jAt4uD7kGnc?si=5zgn6r0HkTpPXA4p"
    title="YouTube video player"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
    allowfullscreen>
  </iframe>
</div>
            <div class="col-md-6">
                <h2 class="mb-4">Defend your side!</h2>
                <p>Play a 1v1 tower defense game against your opponent! Break their walls, attack their towers and conquer their crystal before they take yours! Drag enemy cards into the field to attack your opponent. Don't forget to defend your own side before they attack you back! With a passive income you can keep buying new enemys, walls or ballistas to keep your opponent from winning. Can you win within the 3 minutes? Get the chaos coming!

</p>
            </div>
        </div>
    </section>

 <section class="container py-5">
        <h2 class="mb-4 text-center">Code</h2>
    
        <div class="text-center mb-4">
            <button class="btn btn-secondary mx-2" data-toggle="collapse" data-target="#collapseJump" aria-expanded="true" aria-controls="collapseJump">Touchscreen</button>
            <button class="btn btn-secondary mx-2" data-toggle="collapse" data-target="#collapseStar" aria-expanded="false" aria-controls="collapseStar">Minion attack</button>
            <button class="btn btn-secondary mx-2" data-toggle="collapse" data-target="#collapseWin" aria-expanded="false" aria-controls="collapseWin">Card spawn</button>
        </div>
    
        <div id="accordion">
    
            <!-- Jump -->
            <div id="collapseJump" class="collapse" data-parent="#accordion">
                <div class="bg-primary p-4 rounded mb-4 text-white">
                    <div class="row justify-content-center mt-3">
              <div class="col-md-6">
                <img src="../gifs/splittouch (2).gif" alt="Platform visual" class="img-fluid rounded shadow">
              </div>
            </div>
                    <pre><code>
    public class Touchscreen : MonoBehaviour
{
    private Dictionary<int, GameObject> activeDrags = new Dictionary<int, GameObject>();
    private Camera cam;
    [SerializeField] private float spawnLine;

    private bool mouseDragging = false;
    private GameObject mouseDragObject;

    private TouchPlacer touchPlacer;

    void Start()
    {
        cam = Camera.main;
        touchPlacer = FindFirstObjectByType<TouchPlacer>();
    }

    void OnFingerDown(Finger finger) //place finger on screen
    {
        Vector2 screenPos = finger.screenPosition;
        Ray ray = cam.ScreenPointToRay(screenPos);

        if (Physics.Raycast(ray, out RaycastHit hit))
        {
            GameObject originalCard = hit.collider.gameObject;
            if (originalCard.GetComponent<Card>())
            {
                Card card = originalCard.GetComponent<Card>();
                bool _isRightSide = originalCard.layer == LayerMask.NameToLayer("rotate");

            if (_isRightSide)
            {
                if (card != null && CoinManager.DefendersCoins >= card.CardCost)
                {
                    GameObject cardCopy = Instantiate(originalCard, originalCard.transform.position, originalCard.transform.rotation);
                    cardCopy.tag = "Untagged";

                    CoinManager.LoseDECoins(card.CardCost);

                    activeDrags[finger.index] = cardCopy;
                }
            }            
        }
            else if (originalCard.GetComponent<GridItemPlacer>())
            {
                GridItemPlacer _item = originalCard.GetComponent<GridItemPlacer>();
                bool _isRightSide = _item.IsRightSide;
                int _itemID = _item.ItemToPlace;
                int _prize = touchPlacer.ReturnPrize(_itemID);
                if (_isRightSide)
                {

                if (_item != null && CoinManager.DefendersCoins >= _prize)
                {
                    GameObject _itemCopy = Instantiate(originalCard, originalCard.transform.position, originalCard.transform.rotation);
                    _itemCopy.tag = "Untagged";
                    _itemCopy.GetComponent<Collider>().isTrigger = true;

                    _item.GrabItem();

                    CoinManager.LoseDECoins(_prize);

                    activeDrags[finger.index] = _itemCopy;
                }
              }               
            }
          }
        }

    void OnFingerMove(Finger finger) //finger moving across screen
    {
        if (activeDrags.TryGetValue(finger.index, out GameObject draggedCard))
        {
            Vector2 screenPos = finger.screenPosition;
            float z = cam.WorldToScreenPoint(draggedCard.transform.position).z;
            Vector3 worldPos = cam.ScreenToWorldPoint(new Vector3(screenPos.x, screenPos.y, z));

            draggedCard.transform.position = worldPos;
        }
    }

    void OnFingerUp(Finger finger) //finger releasing screen
    {
        if (activeDrags.TryGetValue(finger.index, out GameObject draggedCard))
        {
            Vector3 spawnPos = draggedCard.transform.position;

            if (draggedCard.GetComponent<Card>())
            {
                Card card = draggedCard.GetComponent<Card>();
                if (card != null)
                {
                    card.OnPlay(spawnPos);
                }
            }
            else if (draggedCard.GetComponent<GridItemPlacer>())
            {
                GridItemPlacer _item = draggedCard.GetComponent<GridItemPlacer>();
                if (_item != null)
                {
                    _item.SpawnItem(spawnPos);
                }
            }

            Destroy(draggedCard);
            activeDrags.Remove(finger.index);
        }
    }
                    </code></pre>       
            <!-- GIF -->
            
        
          </div>
        </div>
    
            <!-- Star -->
            <div id="collapseStar" class="collapse" data-parent="#accordion">
                <div class="bg-primary p-4 rounded mb-4 text-white">
                     <div class="row justify-content-center mt-3">
                        <div class="col-md-6">
                    <img src="../gifs/splitattack.gif" alt="Star Collect" class="img-fluid rounded shadow mt-3">
                </div>
            </div>
                    <pre><code>
                public class MinionAttack : MonoBehaviour
             {
                public MinionScriptableObject MDamageData;
                public MinionScriptableObject MAttackAudio;

                private float coolDown = 2;
                private float reload = 2;

                private AudioSource audioSource;

                private Animator animator;

                [SerializeField] private float radius;
                [SerializeField] private LayerMask layerMask;

                [SerializeField] GameObject projectilePrefab;

                [SerializeField] GameObject lWall;
                [SerializeField] GameObject rWall;


                MinionMovement movement;


                private void Start()
                {
                    animator = GetComponent<Animator>();
                    movement = FindFirstObjectByType<MinionMovement>();
                    audioSource = GetComponent<AudioSource>();
                }
                void Update()
                {
                    coolDown -= Time.deltaTime;
                    if (CompareTag("Range"))
                    {
                        RangeMinion();
                    }
                }

                private void OnCollisionStay(Collision collision)
                {
                    if (collision.collider.CompareTag("Damageable"))
                    {
                        if (coolDown <= 0)
                        {
                            collision.gameObject.GetComponent<Wall>().TakeDamage(MDamageData.MDamage);
                            PlayAudio();
                            if (animator != null) animator.SetTrigger("Attack");
                            coolDown = 2;
                        }
                    }
            

                private void RangeMinion()
                {
                    if (gameObject.layer == LayerMask.NameToLayer("enemyL")) //right minion attacking left minion
                    {
                        Collider[] _targets = Physics.OverlapSphere(transform.position, radius, layerMask);

                        Transform _nearestTarget = GetTarget(_targets);

                        if (_nearestTarget != null && rWall.layer == LayerMask.NameToLayer("TargetsR"))
                        {
                            movement.IsWalking = false;

                            if (coolDown <= 0)
                            {
                                PlayAudio();
                                Attacking(_nearestTarget);
                                coolDown = reload;
                            }

                        }
                        else if (_nearestTarget == null)
                        {
                            movement.IsWalking = true;
                        }
                    }


                    else if (gameObject.layer == LayerMask.NameToLayer("enemyR")) //left minion attacking right minion
                    {
                        Collider[] _targets = Physics.OverlapSphere(transform.position, radius, layerMask);

                        Transform _nearestTarget = GetTarget(_targets);

                        if (_nearestTarget != null && lWall.layer == LayerMask.NameToLayer("TargetsL"))
                        {
                            movement.IsWalking = false;

                            if (coolDown <= 0)
                            {
                                PlayAudio();
                                Attacking(_nearestTarget);
                                coolDown = reload;
                            }

                        }
                        else if (_nearestTarget == null) //range minion only walks when not attacking
                        {
                            movement.IsWalking = true;
                        }
                    }
                }



                private Transform GetTarget(Collider[] _targets)
                {
                    float _minDistance = Mathf.Infinity;
                    Transform _nearest = null;

                    foreach (var _target in _targets)
                    {
                        float _dist = Vector3.Distance(transform.position, _target.transform.position);
                        if (_dist < _minDistance)
                        {
                            _minDistance = _dist;
                            _nearest = _target.transform;
                        }
                    }
                    return _nearest;
                }

                private void Attacking(Transform _targets)
                {
                    GameObject _projectile = Instantiate(projectilePrefab, transform.position, transform.rotation);
                    Projectile _projectileScript = _projectile.GetComponent<Projectile>();

                    _projectileScript.SetTarget(_targets);
                    _projectileScript.Damage = MDamageData.MDamage;
                }
                    </code></pre>
                   
        </div>
    </div>

    
            <!-- death -->
            <div id="collapseWin" class="collapse" data-parent="#accordion">
                <div class="bg-primary p-4 rounded mb-4 text-white">
                    <div class="row justify-content-center mt-3">
                        <div class="col-md-6">
                    <img src="../gifs/splitsplitspawn.gif" alt="Star Collect" class="img-fluid rounded shadow mt-3">
                </div>
            </div>
                    <pre><code>
                            public class Card : MonoBehaviour
                        {
                            [Range(1f, 20f)]
                            public int CardCost;

                            [SerializeField] private GameObject minionPrefab;
                            [SerializeField] private MinionScriptableObject costData;

                            [SerializeField] private float spawnLine;


                            private bool hasBeenPlayed = false;

                            public void OnPlay(Vector3 _spawnPosition)
                            {

                                if (_spawnPosition.z < 4.3f || _spawnPosition.z > 6.2f)
                                {

                                    if (gameObject.layer == LayerMask.NameToLayer("rotate"))
                                    {
                                        CoinManager.AddDECoins(costData.MCost);
                                    }
                                    if (gameObject.layer == LayerMask.NameToLayer("Default"))
                                    {
                                        CoinManager.AddATCoins(costData.MCost);
                                    }

                                    hasBeenPlayed = false; 
                                    Destroy(gameObject);
                                    return;
                                }

                                if (hasBeenPlayed) return;
                                hasBeenPlayed = true;
                                
                                {//it checks if the card isn't too close to the enemy's side to spawn
                                if (gameObject.layer == LayerMask.NameToLayer("rotate"))
                                    if (_spawnPosition.z < spawnLine) { _spawnPosition.z = spawnLine; } 
                                }
                                if (gameObject.layer == LayerMask.NameToLayer("Default"))
                                {
                                    if (_spawnPosition.z > spawnLine) { _spawnPosition.z = spawnLine; }
                                }


                                if (_spawnPosition.x > -3.404f) _spawnPosition.x = -3.404f;
                                if (_spawnPosition.x < -5.147f) _spawnPosition.x = -5.147f;

                                {
                                    if (minionPrefab != null && hasBeenPlayed)
                                    {
                                        _spawnPosition.y = 0.1f; 
                                        if (gameObject.layer == LayerMask.NameToLayer("rotate"))
                                        {
                                            Instantiate(minionPrefab, _spawnPosition, Quaternion.Euler(0, 180, 0));
                                        }
                                        else
                                        {
                                            Instantiate(minionPrefab, _spawnPosition, Quaternion.identity);
                                        }

                                    }
                                }
                            }
                        }
                    </code></pre>
                    
        </div>
    </div>

    
        </div>
    </section>
    


    <!-- Screenshots Grid -->
    <section class="container py-5 text-center">
        <h2 class="mb-4">Screenshots</h2>
        <div class="row">
            <div class="col-md-4">
                <img src="../images/splitt/split2.png" alt="Screenshot 1" class="img-fluid rounded shadow-lg screenshot-img">
            </div>
            <div class="col-md-4">
                <img src="../images/splitt/split4.png" alt="Screenshot 2" class="img-fluid rounded shadow-lg screenshot-img">
            </div>
            <div class="col-md-4">
                <img src="../images/splitt/split3.png" alt="Screenshot 3" class="img-fluid rounded shadow-lg screenshot-img">
            </div>
        </div>
    </section>
    
   


    <!-- Footer -->
    <footer class="text-center py-3 ">
        <p>&copy; 2025 Esmée Veldhuizen🌸</p>
    </footer>

    <!-- Bootstrap JS -->
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.5.2/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>

</body>
</html>
